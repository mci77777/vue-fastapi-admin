# 基础模型设计

<cite>
**本文档引用文件**  
- [app/models/base.py](file://app/models/base.py#L8-L61)
- [app/models/admin.py](file://app/models/admin.py#L8-L78)
- [app/api/v1/users/users.py](file://app/api/v1/users/users.py#L35-L80)
- [app/controllers/user.py](file://app/controllers/user.py#L0-L59)
- [app/schemas/users.py](file://app/schemas/users.py#L0-L43)
- [app/api/v1/base/base.py](file://app/api/v1/base/base.py#L32-L102)
</cite>

## 目录
1. [简介](#简介)
2. [核心基类设计](#核心基类设计)
3. [BaseModel 详解](#basemodel-详解)
4. [TimestampMixin 详解](#timestampmixin-详解)
5. [UUIDModel 详解](#uuidmodel-详解)
6. [to_dict() 方法的序列化机制](#to_dict-方法的序列化机制)
7. [实际应用与继承示例](#实际应用与继承示例)
8. [架构价值与最佳实践](#架构价值与最佳实践)
9. [性能考量与优化建议](#性能考量与优化建议)

## 简介
本项目采用 Tortoise ORM 实现异步数据库操作，其数据模型设计围绕 `BaseModel`、`TimestampMixin` 和 `UUIDModel` 三大核心基类构建。这些基类共同构成了系统中所有实体模型的基础，提供了统一的字段定义、时间戳管理、唯一标识支持以及数据序列化能力。通过多继承机制，各业务模型可灵活组合所需功能，显著减少重复代码，提升开发效率与数据一致性。

## 核心基类设计
系统采用模块化、可复用的基类设计理念，将通用功能解耦为独立的 Mixin 类，便于按需继承与组合。主要基类包括：

```mermaid
classDiagram
class BaseModel {
+id : BigIntField
+async to_dict(m2m : bool, exclude_fields : list[str]) Dict
-async __fetch_m2m_field(field, exclude_fields) Tuple
+class Meta
}
class TimestampMixin {
+created_at : DatetimeField(auto_now_add=True)
+updated_at : DatetimeField(auto_now=True)
}
class UUIDModel {
+uuid : UUIDField(unique=True, index=True)
}
BaseModel <|-- User
BaseModel <|-- Role
BaseModel <|-- Api
BaseModel <|-- Menu
BaseModel <|-- Dept
BaseModel <|-- AuditLog
TimestampMixin <|-- User
TimestampMixin <|-- Role
TimestampMixin <|-- Api
TimestampMixin <|-- Menu
TimestampMixin <|-- Dept
TimestampMixin <|-- AuditLog
User : +username : CharField
User : +email : CharField
User : +is_active : BooleanField
User : +roles : ManyToManyField
```

**图示来源**  
- [app/models/base.py](file://app/models/base.py#L8-L61)
- [app/models/admin.py](file://app/models/admin.py#L8-L78)

## BaseModel 详解
`BaseModel` 是所有数据库实体的基类，继承自 `tortoise.models.Model`，并被标记为抽象类（`abstract = True`），确保其不会生成独立的数据表。

### 核心字段
- **id**: 使用 `BigIntField` 作为主键（`pk=True`），并建立数据库索引以提升查询性能。

### 核心方法
- **to_dict()**: 异步方法，用于将模型实例序列化为字典，支持排除指定字段和递归处理多对多关系。
- **__fetch_m2m_field()**: 私有异步方法，用于并行获取多对多关联对象的数据。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L8-L42)

## TimestampMixin 详解
`TimestampMixin` 提供了自动化的创建和更新时间戳管理。

### 字段定义
- **created_at**: `DatetimeField` 类型，`auto_now_add=True` 确保在对象首次创建时自动填充当前时间。
- **updated_at**: `DatetimeField` 类型，`auto_now=True` 确保在对象每次保存时自动更新为当前时间。

这两个字段均建立了数据库索引，便于按时间范围进行高效查询。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L59-L61)

## UUIDModel 详解
`UUIDModel` 提供了基于 UUID 的唯一标识支持。

### 字段定义
- **uuid**: `UUIDField` 类型，设置 `unique=True` 和 `index=True`，确保全局唯一性并支持高效查询。与 `BaseModel` 的 `id` 字段不同，`uuid` 不作为主键（`pk=False`），可作为业务层面的唯一标识符。

该设计适用于需要对外暴露非自增ID的场景，增强安全性与可读性。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L55-L56)

## to_dict() 方法的序列化机制
`to_dict()` 方法是实现模型数据向 API 响应转换的核心。

### 序列化流程
1. **基础字段处理**: 遍历模型的 `_meta.db_fields`，获取所有数据库字段的值。
2. **日期格式化**: 自动识别 `datetime` 类型的值，并使用 `settings.DATETIME_FORMAT` 进行格式化，避免 JSON 序列化错误。
3. **字段排除**: 支持通过 `exclude_fields` 参数动态排除敏感字段（如 `password`）。
4. **多对多关系处理**: 当 `m2m=True` 时，使用 `asyncio.gather` 并行获取所有多对多关联对象的数据，并递归调用 `to_dict()` 进行序列化。

### 异步优势
该方法为异步实现，能够高效处理包含大量关联数据的复杂查询，避免阻塞事件循环，提升 API 响应速度。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L8-L52)

## 实际应用与继承示例
以下以 `User` 模型为例，展示基类的实际应用。

### 模型定义
```python
class User(BaseModel, TimestampMixin):
    username = fields.CharField(max_length=20, unique=True, index=True)
    email = fields.CharField(max_length=255, unique=True, index=True)
    password = fields.CharField(max_length=128)
    is_active = fields.BooleanField(default=True)
    roles = fields.ManyToManyField("models.Role", related_name="user_roles")
    # ... 其他字段
```
`User` 模型通过多继承同时具备了 `id` 主键、`created_at`/`updated_at` 时间戳以及 `to_dict()` 序列化能力。

### API 中的序列化调用
在用户信息查询接口中，`to_dict()` 方法被直接调用：
```python
@router.get("/get", summary="查看用户")
async def get_user(user_id: int):
    user_obj = await user_controller.get(id=user_id)
    user_dict = await user_obj.to_dict(exclude_fields=["password"])
    return Success(data=user_dict)
```
此调用确保了返回给前端的用户数据不包含密码字段，保障了安全性。

### 前端数据展示
前端 Vue 组件通过 `role` 字段的 `name` 展示用户角色：
```vue
<template>
  <span v-for="role in row.roles" :key="role.id">
    {{ role.name }}
  </span>
</template>
```
这依赖于后端 `to_dict(m2m=True)` 返回的完整角色信息。

**本节来源**  
- [app/models/admin.py](file://app/models/admin.py#L8)
- [app/api/v1/users/users.py](file://app/api/v1/users/users.py#L35-L80)
- [app/schemas/users.py](file://app/schemas/users.py#L0-L43)
- [web/src/views/system/user/index.vue](file://web/src/views/system/user/index.vue#L52-L111)

## 架构价值与最佳实践
### 减少代码重复
通过将通用字段和方法抽象到基类中，所有继承的模型无需重复定义 `id`、`created_at` 等字段，遵循 DRY（Don't Repeat Yourself）原则。

### 确保数据一致性
`TimestampMixin` 确保了所有模型的创建和更新时间由框架统一管理，避免了手动赋值可能导致的不一致。

### 提升开发效率
`to_dict()` 方法提供了开箱即用的序列化功能，开发者无需为每个模型编写重复的 `to_dict` 或 `serialize` 方法。

### 最佳实践建议
1. **始终继承 `BaseModel`**: 所有数据库模型都应继承 `BaseModel` 以获得统一的主键和序列化能力。
2. **按需使用 `TimestampMixin`**: 对于需要记录时间的模型，应继承 `TimestampMixin`。
3. **谨慎使用 `exclude_fields`**: 在序列化时，务必排除敏感字段，如密码、密钥等。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L8-L61)
- [app/models/admin.py](file://app/models/admin.py#L8-L78)

## 性能考量与优化建议
### 异步序列化的优势
`to_dict()` 的异步实现使其能够高效处理多对多关系。`asyncio.gather` 允许并行执行多个数据库查询，显著减少了总响应时间。

### 潜在性能瓶颈
1. **深度嵌套关系**: 如果 `to_dict(m2m=True)` 被用于包含多层嵌套关系的复杂模型，可能会触发大量数据库查询（N+1 问题）。
2. **大数据量**: 对于包含大量关联记录的模型，一次性序列化所有数据可能导致内存占用过高。

### 优化建议
1. **按需加载**: 在 API 接口中，根据前端需求明确指定是否需要 `m2m` 数据，避免不必要的查询。
2. **分页处理**: 对于列表接口，应结合分页机制，避免一次性返回过多数据。
3. **选择性排除**: 利用 `exclude_fields` 参数，排除前端不需要的字段，减小响应体大小。

**本节来源**  
- [app/models/base.py](file://app/models/base.py#L8-L52)
- [app/api/v1/users/users.py](file://app/api/v1/users/users.py#L0-L38)